/**
 * Copyright 2018 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var challengeServices = angular.module('challengeServices', [
    'ngResource',
    'globalServices']);

challengeServices.service('challengeService', [
    '$resource',
    '$rootScope',
    '$cacheFactory',
    '$timeout',
    function($resource, $rootScope, $cacheFactory, $timeout) {
      var cache = $cacheFactory('challengeCache');
      var cacheTimeout = 30000;
      var res = $resource('/api/challenges/:cid', {}, {
        'get': {method: 'GET', cache: cache},
        'save': {method: 'PUT'},
        'create': {method: 'POST'},
        'delete': {method: 'DELETE'},
      });
      this.get = res.get;
      this.delete = res.delete;
      this.save = function() {
        cache.removeAll();
        return res.save.apply(res, arguments);
      };
      this.create = function() {
        cache.removeAll();
        return res.create.apply(res, arguments);
      };
      this.flush = cache.removeAll;
      $rootScope.$on('correctAnswer', cache.removeAll);
      return this;
    }]);

challengeServices.service('tagService', [
    '$resource',
    '$rootScope',
    '$cacheFactory',
    '$timeout',
    function($resource, $rootScope, $cacheFactory, $timeout) {
        var tagCache = $cacheFactory('tagCache');

        this.res = $resource('/api/tags/:tagslug', {}, {
            'get': {method: 'GET', tagCache},
            'save': {method: 'PUT'},
            'create': {method: 'POST'},
        })

        this.get = this.res.get;
        this.save = this.res.save;
        this.create = this.res.create;
        this.delete = this.res.delete;

        this.getList = function(callback) {
            if (this.taglist) {
                callback(this.taglist);
                return;
            }
            this.res.get(angular.bind(this, function(data) {
                this.taglist = data;
                $timeout(
                    angular.bind(this, function() {
                        this.taglist = null;
                        tagCache.removeAll();
                    }),
                30000, false);
                callback(data);
            }))
            $rootScope.$on('$locationChangeSuccess', function() {
                this.taglist = null;
                tagCache.removeAll();
            });
        }

    }
])

challengeServices.service('attachService', [
    '$resource',
    '$rootScope',
    '$cacheFactory',
    '$timeout',
    function($resource, $rootScope, $cacheFactory, $timeout) {
        var attachCache = $cacheFactory('attachCache');

        this.res = $resource('/api/attachments/:aid', {}, {
            'get': {method: 'GET', attachCache},
            'save': {method: 'PUT'},
        })

        this.get = this.res.get;
        this.create = this.res.create;
        this.save = this.res.save;
        this.delete = this.res.delete;

        this.getList = function(callback) {
            if (this.attachlist) {
                callback(this.attachlist);
                return;
            }
            this.res.get(angular.bind(this, function(data) {
                this.attachlist = data;
                $timeout(
                    angular.bind(this, function() {
                        this.attachlist = null;
                        attachCache.removeAll();
                    }),
                30000, false);
                callback(data);
            }))
            $rootScope.$on('$locationChangeSuccess', function() {
                this.attachlist = null;
                attachCache.removeAll();
            });
        }

    }
])

challengeServices.service('answerService', [
    '$resource',
    '$rootScope',
    function($resource, $rootScope) {
      this.res = $resource('/api/answers/:aid', {}, {
        'create': {method: 'POST'}
      });
      this.create = function(what, success, failure) {
        this.res.create(what,
            function(resp) {
              success(resp);
              $rootScope.$broadcast('correctAnswer');
            },
            failure);
      };
    }]);

challengeServices.service('validatorService', [
    '$resource',
    '$rootScope',
    function($resource, $rootScope) {
      this.res = $resource('/api/validator', {}, {
        'create': {method: 'POST'}
      });
      this.create = function(what, success, failure) {
        this.res.create(what,
            function(resp) {
              success(resp);
            },
            failure);
      };
    }]);

challengeServices.service('scoreService', [
    'configService',
    function(configService) {
      this.scoring = 'plain';
      configService.get(angular.bind(this, function(cfg) {
        this.scoring = cfg.scoring;
      }));
      this.getCurrentPoints = function(challenge) {
        if (!challenge)
          return 0;
        return challenge.current_points;
      };
    }])
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* upload services */
var uploadServices = angular.module('uploadServices', ['ngResource']);

uploadServices.service('uploadService', ['$http', '$q',
    function($http, $q) {
        var basename = function(path) {
            return path.split('/').reverse()[0];
        };

        this.request = function() {
            return $q(function(resolve) {
                var form = $('#new-attachment');
                form.click();
                form.off('change');
                form.on('change', function() {
                  resolve(form.get(0).files[0]);
                })
            })
        }
        this.upload = function(file) {
            // Returns a promise with the file hash
            var filename = basename(file.name);
            // Construct the promise
            var promise = $q.defer();
            // HTTP Config
            var config = {
                transformRequest: angular.identity,
                'headers': {
                    'Content-type': undefined
                }
            };

            // Setup form data
            var fd = new FormData();
            fd.append('file', file);
            // Request
            $http.post('/api/attachments', fd, config).
                success(function(data) {
                    data.filename = filename;
                    promise.resolve(data);
                }).
                error(function(data, status) {
                    if (data)
                        promise.reject(data);
                    else
                        promise.reject('Unknown upload error.');
                });
            return promise.promise;
        };
    }]);
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var teamServices = angular.module('teamServices', ['ngResource']);

teamServices.service('teamService', ['$resource',
    function($resource) {
      var resource = $resource('/api/teams/:tid', {}, {
        save: {method: 'PUT'},
        create: {method: 'POST'}
        });
      resource.change = function(data, cb, error) {
        return resource.save({tid: "change"}, data, cb, error);
      }
      return resource;
    }]);
/**
 * Copyright 2018 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Global services */
var globalServices = angular.module('globalServices', ['ngResource']);

globalServices.service('configService', [
    '$resource',
    function($resource) {
      return $resource('/api/config', {}, {
        'get': {cache: true}
      });
    }]);


globalServices.service('errorService',
    function() {
      var inhibit = false;
      this.errors = [];

      this.clearErrors = angular.bind(this, function() {
        if (inhibit) {
          inhibit = false;
          return;
        }
        this.errors.length = 0;
      });

      this.error = angular.bind(this, function(msg, severity) {
        severity = severity || 'danger';
        if (typeof msg == "object") {
          msg = (msg.data && msg.data.message) || msg.message || "Request Error";
        }
        this.errors.push({severity: severity, msg: msg});
      });

      this.success = angular.bind(this, function(msg) {
        this.error(msg, 'success');
      });

      this.inhibitClear = function() {
        inhibit = true;
      };

      this.clearAndInhibit = angular.bind(this, function() {
        inhibit = false;
        this.clearErrors();
        this.inhibitClear();
      });
    });


globalServices.service('proofOfWorkService', [
  'configService',
  function(configService) {
    //angular.injector(['globalServices']).get('proofOfWorkService')
    var subtle = window.crypto.subtle;

    // Returns a promise with the key
    this.proofOfWork = function(instr) {
      return new Promise(function(resolve, reject) {
        configService.get(function(cfg) {
          var nbits = cfg.proof_of_work_bits;
          if (nbits == 0) {
            resolve('');
            return;
          }
          _proofOfWork(instr, nbits).then(resolve).catch(reject);
        });
      });
    };

    // Internal implementation
    var _proofOfWork = function(instr, nbits) {
      var start = Date.now();
      return new Promise(function(resolve, reject) {
        var resolver = function(k) {
          var end = Date.now();
          console.log('Proof of work took ' + (end - start) + ' ms');
          resolve(k);
        };
        // Sortof recursive -- not great, but best I can come up.
        // Patches welcome.
        var callTry = function() {
          return _tryProofOfWork(instr, nbits)
              .then(function(k) {
                  if (k == null) {
                      callTry();
                      return;
                  }
                  resolver(k);
              }).catch(function(e) {
                  console.error('Error in proof of work: ' + e);
                  reject(e);
              });
        };
        callTry();
      });
    };

    // HMAC with random key
    // Promise is fulfilled with args (key, signature)
    var _hmacRandom = function(instr) {
      var buf = new TextEncoder("utf-8").encode(instr);
      return new Promise(function(resolve, reject) {
        subtle.generateKey(
          {
            name: 'HMAC',
            hash: {name: 'SHA-256'},
            length: 256
          },
          true,
          ['sign'])
          .then(function(key) {
            subtle.sign(
              {name: 'HMAC'},
              key,
              buf
            )
            .then(function(signature) {
              resolve({key: key, signature: new Uint8Array(signature)});
            })
            .catch(reject);
          })
          .catch(reject);
      });
    };

    var testbits = function(arr, nbits) {
      while (nbits >= 8) {
        if (arr[0] != 0)
          return false;
        nbits -= 8;
        arr = arr.slice(1);
      }
      var mask = Math.round(Math.pow(2, nbits)) - 1;
      return ((arr[0] & mask) == 0);
    };

    // Try to find a key with low bits set to 0
    var _tryProofOfWork = function(instr, nbits) {
      return new Promise(function(resolve, reject) {
        _hmacRandom(instr)
        .then(function(params) {
          if (testbits(params.signature, nbits)) {
            subtle.exportKey('jwk', params.key)
            .then(function(k) {
              resolve(k.k);
            })
            .catch(reject);
          } else {
            // Not a match
            resolve(null);
          }
        })
        .catch(reject);
      });
    };

    // Useful for tuning
    window._proofOfWork = _proofOfWork;
  }]);


globalServices.service('loadingService', [
    '$timeout',
    function($timeout) {
        // Basically just keeps a loading flag
        var loading = false;
        var loadTimer = null;
        var debounce = 250;  // Debounce ms

        this.getState = function() {
            return loading;
        };
        this.start = function() {
            if (loadTimer || loading)
                return;
            loadTimer = $timeout(
                function() {
                    loading = true;
                }, debounce);
        };
        this.end = function() {
            if (loadTimer) {
                $timeout.cancel(loadTimer);
                loadTimer = null;
            }
            loading = false;
        };
        this.stop = this.end;
    }]);


globalServices.service('gameTimeService', [
    '$q',
    'configService',
    'errorService',
    function($q, configService, errorService) {
        var future = $q.defer();
        this.start = null;
        this.end = null;

        configService.get(
            angular.bind(this, function(config) {
                this.start = config.game_start && Date.parse(config.game_start);
                this.end = config.game_end && Date.parse(config.game_end);
                future.resolve();
            }),
            function(data) {
                errorService.error(data);
            });

        this.toStart = function() {
            // Time in seconds to start of game, or null if no start specified
            if (!this.start)
                return null;
            return Math.round((this.start - Date.now()) / 1000);
        };

        this.toEnd = function() {
            // Time in seconds to end of game, or null if no end specified
            if (!this.end)
                return null;
            return Math.round((this.end - Date.now()) / 1000);
        };

        this.duringGame = function(opt_callback) {
            // Return true or execute callback if in the game
            if (this.start != null && this.toStart() > 0)
                return false;
            if (this.end != null && this.toEnd() < 0)
                return false;
            if (opt_callback)
                return opt_callback();
            return true;
        };

        this.started = angular.bind(this, function() {
            return !this.start || this.toStart() < 0
        })

        this.then = function(callback) {
          future.promise.then(callback);
        };
    }]);


globalServices.service('newsService', [
    '$resource',
    '$interval',
    'configService',
    function($resource, $interval, configService) {
        this.newsResource = $resource('/api/news');
        this.get = this.newsResource.get;
        this.query = this.newsResource.query;
        this.save = this.newsResource.save;
        this.pollPromise_ = undefined;
        this.inFlight_ = false;

        // Callbacks to be called on new news
        this.clients_ = [];
        this.registerClient = function(client) {
            this.clients_.push(client);
        };

        // Polling handler
        this.poll = function() {
            if (this.inFlight_)
                return;
            this.inFlight_ = true;
            this.newsResource.query(angular.bind(this, function(data) {
                angular.forEach(this.clients_, function(cb) {
                    cb(data);
                });
                this.inFlight_ = false;
            }), angular.bind(this, function() { this.inFlight_ = false }));
        };

        // Set up polling
        this.start = function() {
            if (this.pollPromise_)
                return;
            this.poll();
            configService.get(angular.bind(this, function(config) {
                if (config.news_mechanism != 'poll')
                    return;
                var interval = config.news_poll_interval || 60000;  // 60 seconds
                this.pollPromise_ = $interval(angular.bind(this, this.poll), interval);
            }));
        };

        // Shutdown
        this.stop = function() {
            $interval.cancel(this.pollPromise_);
            this.pollPromise_ = undefined;
        };
    }]);
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var sessionServices = angular.module('sessionServices', [
    'ngResource',
    'globalServices',
    ]);

sessionServices.service('sessionService', [
    '$resource', '$location', '$rootScope', 'errorService',
    function($resource, $location, $rootScope, errorService) {
      this.sessionData = $resource('/api/session');
      this.session = {
        user: null,
        team: null
      };

      this.login = function(email, password, successCallback, errorCallback) {
        this.sessionData.save({email: email, password: password},
          angular.bind(this, function(data) {
            this.session.user = data.user;
            this.session.team = data.team;
            if (successCallback)
              successCallback();
            $rootScope.$broadcast('sessionLogin');
          }), errorCallback || function() {});
      };

      this.logout = function(callback) {
        this.sessionData.remove(function() {
          $rootScope.$broadcast('sessionLogout');
          callback();
        });
        this.session.user = null;
        this.session.team = null;
      };

      this.refresh = function(successCallback, errorCallback) {
        // Attempt to load
        this.sessionData.get(angular.bind(this, function(data) {
          var currUser = this.session.user && this.session.user.nick;
          this.session.user = data.user;
          this.session.team = data.team;
          if (currUser && !this.session.user)
            $rootScope.$broadcast('sessionLogout');
          if (!currUser && this.session.user)
            $rootScope.$broadcast('sessionLogin');
          if (successCallback)
            successCallback();
        }), errorCallback || function() {});
      };

      this.requireLogin = function(callback, no_redirect) {
        /* If the user is logged in, execute the callback.  Otherwise, redirect
         * to the login. */
        if (this.session.user !== null) {
          return callback();
        }
        return this.refresh(callback,
            function() {
              if (no_redirect)
                return;
              errorService.clearAndInhibit();
              errorService.error('You must be logged in.', 'info');
              $location.path('/login');
            });
      };

      this.requireAdmin = function(opt_callback) {
        var cb = angular.bind(this, function() {
          if (this.session.user && this.session.user.admin) {
            if (opt_callback)
                opt_callback();
            return true;
          }
          errorService.clearAndInhibit();
          errorService.error('You are not an admin!');
          $location.path('/');
          return false;
        });
        if (this.session.user != null) {
          return cb();
        }
        this.requireLogin(cb);
        return true;
      };

      this.refresh();
    }]);

function getss(){
  return angular.element(document).injector().get('sessionService');
}
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* page services */
var pageServices = angular.module('pageServices', ['ngResource']);

pageServices.service('pageService', [
    '$resource',
    '$location',
    function($resource, $location) {
        this.pagelist = [];

        this.resource = $resource('/api/page/:path');
        this.get = this.resource.get;
        this.save = this.resource.save;
        this.delete = this.resource.delete;

        /** Return path to page with prefix stripped. */
        this.pagePath = function(prefix) {
            prefix = prefix || '/';
            var path = $location.path();
            if (path.substr(0, prefix.length) == prefix) {
                path = path.substr(prefix.length);
            }
            return path;
        };

        this.getList = function(callback) {
            if (this.pagelist) {
                callback(this.pagelist);
                return;
            }
            this.res.get(angular.bind(this, function(data) {
                this.pagelist = data;
                $timeout(
                    angular.bind(this, function() {
                        this.pagelist = null;
                    }),
                60000, false);
                callback(data);
            }))
            $rootScope.$on('$locationChangeSuccess', function() {
                this.pagelist = null;
            });
        }

    }]);
/**
 * Copyright 2018 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Admin-only services */
var adminServices = angular.module('adminServices', ['ngResource']);

adminServices.service('adminToolsService', [
    '$resource',
    function($resource) {
      this.recalculateScores = $resource('/api/tools/recalculate').save;
      this.resetScores = function(cb, err) {
        return $resource('/api/tools/reset').save(
          {op: "scores", ack: "ack"}, cb, err);
      };
      this.resetPlayers = function(cb, err) {
        return $resource('/api/tools/reset').save(
          {op: "players", ack: "ack"}, cb, err);
      };
    }]);
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var userServices = angular.module('userServices', ['ngResource']);

userServices.service('userService', [
    '$resource',
    function($resource) {
      return $resource('/api/users/:uid', {}, {
        'save': {method: 'PUT'},
        'create': {method: 'POST'}
      });
    }]);

userServices.service('passwordResetService', [
    '$resource',
    function($resource) {
        return $resource('/api/pwreset/:email');
    }]);

userServices.service('apiKeyService', [
    '$resource',
    function($resource) {
        return $resource('/api/apikey/:keyid', {}, {
            'create': {method: 'POST'},
            'deleteAll': {method: 'DELETE', params:{}}
        });
    }]);
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var sbDirectives = angular.module('sbDirectives', [
        'challengeServices',
        'globalServices',
        'ngSanitize'
        ]);

sbDirectives.directive('highlightActive', [
    '$location',
    function($location) {
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                scope.$watch(function() { return $location.path(); },
                    function() {
                        if (element[0].pathname == $location.path()) {
                            element.addClass('active is-active');
                        } else {
                            element.removeClass('active is-active');
                        }
                    });
            }
        };
    }]);

sbDirectives.directive('countdownTimer', [
    '$interval',
    'gameTimeService',
    function($interval, gameTimeService) {
        return {
            restrict: 'AE',
            scope: true,
            templateUrl: '/partials/components/countdown.html',
            link: function(scope) {
                var iprom = null;
                var splitTime = function(time) {
                    var t = {};
                    t.seconds = time % 60;
                    time = Math.floor(time/60);
                    t.minutes = time % 60;
                    t.hours = Math.floor(time / 60);
                    return t;
                };
                var refresh = function() {
                    var timeleft = gameTimeService.toStart();
                    if (timeleft > 0) {
                        // Not yet started
                        scope.to = "starts";
                        scope.time = splitTime(timeleft);
                        return;
                    }
                    timeleft = gameTimeService.toEnd();
                    if (timeleft > 0) {
                        // During game
                        scope.to = "ends";
                        scope.time = splitTime(timeleft);
                        return;
                    }
                    // Game over or no end
                    if (iprom) {
                        $interval.cancel(iprom);
                        iprom = null;
                    }
                    if (!gameTimeService.end)
                        scope.message = "Game on!";
                    else
                        scope.message = "Game over.";
                };
                gameTimeService.then(function() {
                    if (!gameTimeService.start && !gameTimeService.end)
                        return;
                    scope.display = true;
                    refresh();
                    iprom = $interval(refresh, 1000);
                });
                scope.display = false;
            }
        };
    }]);

sbDirectives.directive('loadingOverlay', [
    'loadingService',
    function (loadingService) {
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                scope.$watch(function() { return loadingService.getState(); },
                    function() {
                        if (loadingService.getState())
                            element.show();
                        else
                            element.hide();
                    });
            }
        };
    }]);


/* Score over time charts based on Chart.Scatter.js
 * chartData should be an object with structure like:
 * {"label": [{time: datestring, score: value}...], ...}
 */
sbDirectives.directive('scoreChart', [
    '$filter',
    function($filter) {
      return {
        restrict: 'AE',
        replace: false,
        scope: {
          chartData: '=',
          startDate: '@',
          endDate: '@'
        },
        link: function(scope, element, attrs) {
          if (!Chart || Chart === undefined) {
            console.log('Chart.js is not available.');
            element.remove();
            return;
          }
          var padding = 5;
          var colorScheme = [
            '#a6cee3',
            '#1f78b4',
            '#b2df8a',
            '#33a02c',
            '#fb9a99',
            '#e31a1c',
            '#fdbf6f',
            '#ff7f00',
            '#cab2d6',
            '#6a3d9a',
            '#ffff99',
            '#b15928'];
          var withLegend = (attrs.withLegend !== undefined);

          var getDate = function(d) {
            if (d === undefined)
              return null;
            return new Date(d);
          };

          scope.$watch('chartData', function() {
            if (scope.chartData === undefined)
              return;
            element.empty();

            var legendWidth = Math.min(100, Math.floor(element.width() * 0.2));

            var startDate = getDate(scope.startDate);
            var endDate = getDate(scope.endDate);

            // Transform data
            var datasets = [];
            angular.forEach(scope.chartData, function(series, label) {
              var color = colorScheme[datasets.length % colorScheme.length];
              var set = {
                label: $filter('escapeHtml')(label),
                strokeColor: color,
                data: []
              };
              var rawData = [];
              angular.forEach(series, function(point) {
                rawData.push({x: new Date(point.when), y: point.score});
              });
              if (rawData.length == 0)
                return;
              rawData.sort(function(a, b) {
                if (a.x < b.x)
                  return -1;
                if (a.x > b.x)
                  return 1;
                return 0;
              });
              // Trim for start and end date
              if (startDate != null || endDate != null) {
                var startValue = null;
                var endValue = null;
                angular.forEach(rawData, function(point) {
                  if (startDate !== null && point.x < startDate) {
                    startValue = point.y;
                  } else if (endDate !== null && point.x > endDate) {
                    if (endValue !== null) {
                      set.data.push({x: endDate, y: endValue});
                      endValue = null;
                    }
                  } else {
                    if (startValue !== null) {
                      set.data.push({x: startDate, y: startValue});
                      startValue = null;
                    }
                    set.data.push(point);
                  }
                });
              } else {
                set.data = rawData;
              } // end pruning data
              // Nothing after pruning
              if (set.data.length == 0) {
                if (startValue != null) {
                  set.data.push({x: startDate, y: startValue});
                } else {
                  return;
                }
              }
              // Extend to present
              var endPointDate = endDate || (new Date());
              var last = set.data[set.data.length - 1];
              if (last.x < endPointDate)
                set.data.push({x: endPointDate, y: last.score});
              datasets.push(set);
            });

            var options = {
              pointDot: false,
              scaleType: "date",
              useUtc: false,
              scaleTimeFormat: "HH:MM",
              scaleDateTimeFormat: "mmm d, HH:MM"
            };

            // Create canvas inside our element
            var canvas = document.createElement("canvas");
            canvas.height = element.height();
            if (withLegend)
              // Leave space for legend
              canvas.width = element.width() - legendWidth - padding;
            else
              canvas.width = element.width() - padding;

            var legend;
            if (withLegend) {
              // Prepare a legend
              legend = document.createElement("div");
              element.append(legend);
              legend.style.width = legendWidth;
              legend.style.maxWidth = legendWidth;
              $(legend).addClass('sbchart-legend');
            }
            // canvas comes after legend
            element.append(canvas);

            var ctx = canvas.getContext("2d");
            var stepChart = new Chart(ctx).Step(datasets, options);
            if (withLegend)
              legend.innerHTML = stepChart.generateLegend();
          });
        }
      };
    }]);


/* Draw a donut chart of, well, anything.
 * Expects data like:
 * {tag: value}
 */
sbDirectives.directive('donutChart', [
    '$filter',
    function($filter) {
      return {
        restrict: 'AE',
        replace: false,
        scope: {
          chartData: '='
        },
        link: function(scope, element, attrs) {
          if (!Chart || Chart === undefined) {
            console.log('Chart.js is not available.');
            element.remove();
            return;
          }
          var colorScheme = [
            '#a6cee3',
            '#1f78b4',
            '#b2df8a',
            '#33a02c',
            '#fb9a99',
            '#e31a1c',
            '#fdbf6f',
            '#ff7f00',
            '#cab2d6',
            '#6a3d9a',
            '#ffff99',
            '#b15928'];
          var withLegend = (attrs.withLegend !== undefined);

          scope.$watch('chartData', function() {
            /* TODO: add a legend */
            if (scope.chartData === undefined)
              return;
            element.empty();

            // Massage the data
            var dataset = [];
            var numElements = 0;
            angular.forEach(scope.chartData, function() {
              numElements++;
            });
            var getColors;
            var colorIdx = 0;
            if ((numElements * 2) < colorScheme.length) {
              getColors = function() {
                var rv = [colorScheme[colorIdx * 2], colorScheme[colorIdx * 2 + 1]];
                colorIdx ++;
                return rv;
              };
            } else {
              getColors = function() {
                var rv = [colorScheme[colorIdx], colorScheme[colorIdx]];
                colorIdx ++;
                return rv;
              };
            }
            angular.forEach(scope.chartData, function(value, key) {
              var colors = getColors();
              dataset.push({
                value: value,
                color: colors[0],
                highlight: colors[1],
                label: $filter('escapeHtml')(key)
              });
            });

            // Create our canvas
            var canvas = document.createElement("canvas");
            canvas.height = element.height();
            canvas.width = element.width();
            element.append(canvas);

            var options = {
              percentageInnerCutout: 30
            };

            var ctx = canvas.getContext("2d");
            var donutChart = new Chart(ctx).Doughnut(dataset, options);
          });
        }
      };
    }]);


/*
 * Do a single challenge.
 */
sbDirectives.directive('challengeBox', [
    '$resource',
    '$location',
    '$rootScope',
    'answerService',
    'errorService',
    'loadingService',
    'proofOfWorkService',
    'scoreService',
    'sessionService',
    'validatorService',
    function($resource, $location, $rootscope, answerService, errorService,
      loadingService, proofOfWorkService, scoreService, sessionService,
      validatorService) {
      return {
        restrict: 'AE',
        templateUrl: '/partials/components/challenge.html',
        scope: {
          chall: '=challenge'
        },
        link: function(scope, iElement, iAttrs) {
          var isModal = iElement.parents('.modal').length > 0;

          scope.isModal = isModal;
          scope.minteams = 4
          scope.numteams = scope.minteams;
          scope.loggedIn = (!!sessionService.session.user);

          var closeModal = function(href) {
            if (isModal) {
              iElement.parents('.modal').modal('hide');
              if (href) {
                $('.modal').on('hidden.bs.modal', function(e) {
                  $location.path(href)
                  if (!$rootscope.$$phase) $rootscope.$apply()
                })
              }
            } else if (href) {
              $location.path(href)
            }
          };

          scope.closeModal = closeModal;

          scope.$watch('chall', function() {
            // Current points
            scope.currentPoints = scoreService.getCurrentPoints(scope.chall);
            // Update loggedIn
            scope.loggedIn = (!!sessionService.session.user);
            // Recent solves
            scope.recent = function() {
              if (!scope.chall) return []
              var answers = scope.chall.answers.map(function(e, i) {
                e.date = (new Date(e.timestamp)).valueOf();
                return e;
              })
              answers.sort(function(a, b) {
                if (a.date > b.date) return 1
                return -1
              })
              var num = scope.numteams
              if (num < 0) {
                return answers
              }
              return answers.slice(0, num)
            }
          });

          // Setup submit handler
          scope.submitChallenge = function() {
            loadingService.start();
            errorService.clearErrors();
            var done = function() {
              loadingService.stop();
              closeModal();
            };
            var answer = $.trim(scope.chall.answer);
            if (scope.isAdmin()) {
              validatorService.create(
                {cid: scope.chall.cid, answer: answer},
                function(resp) {
                  errorService.error(resp.message, 'success');
                  done();
                },
                function(resp) {
                  errorService.error(resp);
                  done();
                });
              return;
            }
            proofOfWorkService.proofOfWork(answer)
                .then(function (k) {
                  answerService.create(
                      {
                        cid: scope.chall.cid,
                        answer: answer,
                        token: k
                      },
                      function(resp) {
                        scope.chall.answered = true;
                        errorService.error(
                            'Congratulations, ' + resp.points + ' points awarded!',
                            'success');
                        done();
                      },
                      function(resp){
                        errorService.error(resp);
                        done();
                      });
                })
                .catch(function (e) {
                  errorService.error('Error in proof of work: '+e);
                  done();
                });
          };

          scope.timeFormat = function(timestamp) {
            var time = moment(timestamp);
            var duration = moment.duration(time.diff(moment.now()))
            //Time ago in ms
            var msdiff = duration.valueOf()
            var week = 60 * 60 * 24 * 7 * 1000
            if (msdiff < week) {
              return duration.humanize(true);
            } else {
              return time.format("ddd, MMM Do")
            }
          };

          // isAdmin, similar to global controller
          scope.isAdmin = function() {
            return (!!sessionService.session.user &&
                sessionService.session.user.admin);
          };

        } // Link function
      }
    }]);

sbDirectives.directive('ngAnyClick', [
    "$parse",
    function($parse) {
        return function(scope, element, attr) {
            var call = $parse(attr.ngAnyClick);
            element.bind('click', function(e) {
                scope.$apply(function() {
                    e.preventDefault();
                    call(scope, {$event:event, $click: 0});
                })
            })
            element.bind('contextmenu', function(e) {
                scope.$apply(function() {
                    e.preventDefault();
                    call(scope, {$event:event, $click: 1});
                })
            })
        }
    }])
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var sbFilters = angular.module('sbFilters', []);

sbFilters.filter('markdown', [
    '$sce',
    function($sce) {
        return function(input) {
            if (typeof input != "string")
                return "";
            if (typeof Markdown == "undefined" ||
                typeof Markdown.getSanitizingConverter == "undefined") {
                    console.log('Markdown not available!');
                    return input;
            }
            var converter = Markdown.getSanitizingConverter();
            return $sce.trustAsHtml(converter.makeHtml(input));
        };
    }]);

sbFilters.filter('padint',
    function() {
        return function(n, len) {
            if (!len)
                len = 2;
            else
                len = parseInt(len);
            n = '' + n;
            while(n.length < len)
                n = '0' + n;
            return n;
        };
    });

sbFilters.filter('escapeHtml', [
    function() {
      return function(input) {
        return $("<div/>").text(input).html();
      };
    }]);
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var scoreboardApp = angular.module('scoreboardApp', [
  'ngRoute',
  'ngSanitize',
  'adminChallengeCtrls',
  'adminNewsCtrls',
  'adminPageCtrls',
  'adminTeamCtrls',
  'adminToolCtrls',
  'challengeCtrls',
  'globalCtrls',
  'pageCtrls',
  'regCtrls',
  'scoreboardCtrls',
  'teamCtrls',
  'sbDirectives',
  'sbFilters'
]);

scoreboardApp.config([
    '$routeProvider',
    '$locationProvider',
    function($routeProvider, $locationProvider) {
      $locationProvider.html5Mode(true);
      $routeProvider.
        when('/', {
          templateUrl: '/partials/page.html',
          controller: 'StaticPageCtrl'
        }).
        when('/login', {
          templateUrl: '/partials/login.html',
          controller: 'LoginCtrl'
        }).
        when('/logout', {
          templateUrl: '/partials/login.html',
          controller: 'LoginCtrl'
        }).
        when('/register', {
          templateUrl: '/partials/register.html',
          controller: 'RegistrationCtrl'
        }).
        when('/profile', {
          templateUrl: '/partials/profile.html',
          controller: 'ProfileCtrl'
        }).
        when('/challenges/', {
          templateUrl: '/partials/challenge_grid.html',
          controller: 'ChallengeGridCtrl'
        }).
        when('/scoreboard', {
          templateUrl: '/partials/scoreboard.html',
          controller: 'ScoreboardCtrl'
        }).
        when('/teams/:tid', {
          templateUrl: '/partials/team.html',
          controller: 'TeamPageCtrl'
        }).
        when('/pwreset/:email/:token', {
          templateUrl: '/partials/pwreset.html',
          controller: 'PasswordResetCtrl'
        }).
        when('/admin/tags', {
          templateUrl: '/partials/admin/tags.html',
          controller: 'AdminTagCtrl'
        }).
        when('/admin/attachments', {
          templateUrl: '/partials/admin/attachments.html',
          controller: 'AdminAttachmentCtrl'
        }).
        when('/admin/challenges/:cid?', {
          templateUrl: '/partials/admin/challenges.html',
          controller: 'AdminChallengesCtrl'
        }).
        when('/admin/challenge/:cid?', {
          templateUrl: '/partials/admin/challenge.html',
          controller: 'AdminChallengeCtrl'
        }).
        when('/admin/backups', {
          templateUrl: '/partials/admin/restore.html',
          controller: 'AdminRestoreCtrl'
        }).
        when('/admin/teams/:tid?', {
          templateUrl: '/partials/admin/teams.html',
          controller: 'AdminTeamsCtrl'
        }).
        when('/admin/users/:uid?', {
          templateUrl: '/partials/admin/users.html',
          controller: 'AdminUsersCtrl'
        }).
        when('/admin/news', {
          templateUrl: '/partials/admin/news.html',
          controller: 'AdminNewsCtrl'
        }).
        when('/admin/page/:path', {
          templateUrl: '/partials/admin/page.html',
          controller: 'AdminPageCtrl'
        }).
        when('/admin/pages', {
          templateUrl: '/partials/admin/pages.html',
          controller: 'AdminPagesCtrl'
        }).
        when('/admin/tools', {
          templateUrl: '/partials/admin/tools.html',
          controller: 'AdminToolCtrl'
        }).
        otherwise({
          templateUrl: '/partials/page.html',
          controller: 'StaticPageCtrl'
        });
    }]);


scoreboardApp.run([
    '$rootScope',
    'loadingService',
    function($rootScope, loadingService) {
        $rootScope.$on('$locationChangeStart', function() {
            loadingService.start();
        });
    }]);

var getInjector = function() {
    return angular.element('*[ng-app]').injector();
};
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Step chart derived from Chart.Scatter.js

(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['Chart'], factory);
	} else if (typeof exports === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		factory(require('Chart'));
	} else {
		// Browser globals (root is window)
		factory(root.Chart);
	}
}(this, function (chartjs) {

	"use strict";

	var helpers = chartjs.helpers,
		hlp = {
			formatDateValue: function (date, tFormat, dFormat, useUtc) {

				date = new Date(+date);

				var ms = useUtc ? date.getUTCMilliseconds() : date.getMilliseconds();

				if (ms) {

					return ('000' + ms).slice(-3);
				}

				var hasTime = useUtc
					? date.getUTCHours() + date.getUTCMinutes() + date.getUTCSeconds()
					: date.getHours() + date.getMinutes() + date.getSeconds();

				if (hasTime) {

					return dateFormat(date, tFormat || "h:MM", useUtc);
				} else {

					return dateFormat(date, dFormat || "mmm d", useUtc);
				}
			},

			getElementOrDefault: function (array, index, defaultValue) {

				return index >= 0 && index < array.length
					? array[index]
					: defaultValue;
			},

			applyRange: function (value, min, max) {

				return value > max ? max
					: value < min ? min
					: value;
			},
			StepPoint: chartjs.Point.extend({

				inRange: function (chartX, chartY) {
					var hitDetectionRange = this.hitDetectionRadius + this.radius * this.size;
					return ((Math.pow(chartX - this.x, 2) + Math.pow(chartY - this.y, 2)) < Math.pow(hitDetectionRange, 2));
				},

				draw: function () {

					if (this.display && this.size > 0) {

						var ctx = this.ctx;
						ctx.beginPath();

						ctx.arc(this.x, this.y, this.size * this.radius, 0, Math.PI * 2);
						ctx.closePath();

						ctx.strokeStyle = this.strokeColor;
						ctx.lineWidth = this.strokeWidth;

						ctx.fillStyle = this.fillColor;

						ctx.fill();
						ctx.stroke();
					}
				}
			})
		};

	var dateFormat = function () {

		var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
			timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
			timezoneClip = /[^-+\dA-Z]/g,
			pad = function (val, len) {

				val = String(val);
				len = len || 2;
				while (val.length < len) val = "0" + val;
				return val;
			},
			masks = {
				"default": "ddd mmm dd yyyy HH:MM:ss"
			},
			i18n = {
				dayNames: [
					"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
					"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
				],
				monthNames: [
					"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
					"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
				]
			};



		// Regexes and supporting functions are cached through closure
		return function (date, mask, utc) {

			// You can't provide utc if you skip other args (use the "UTC:" mask prefix)
			if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
				mask = date;
				date = undefined;
			}

			// Passing date through Date applies Date.parse, if necessary
			date = date ? new Date(date) : new Date;
			if (isNaN(date)) throw SyntaxError("invalid date");

			mask = String(masks[mask] || mask || masks["default"]);

			// Allow setting the utc argument via the mask
			if (mask.slice(0, 4) == "UTC:") {
				mask = mask.slice(4);
				utc = true;
			}

			var _ = utc ? "getUTC" : "get",
				d = date[_ + "Date"](),
				D = date[_ + "Day"](),
				m = date[_ + "Month"](),
				y = date[_ + "FullYear"](),
				H = date[_ + "Hours"](),
				M = date[_ + "Minutes"](),
				s = date[_ + "Seconds"](),
				L = date[_ + "Milliseconds"](),
				o = utc ? 0 : date.getTimezoneOffset(),
				flags = {
					d: d,
					dd: pad(d),
					ddd: i18n.dayNames[D],
					dddd: i18n.dayNames[D + 7],
					m: m + 1,
					mm: pad(m + 1),
					mmm: i18n.monthNames[m],
					mmmm: i18n.monthNames[m + 12],
					yy: String(y).slice(2),
					yyyy: y,
					h: H % 12 || 12,
					hh: pad(H % 12 || 12),
					H: H,
					HH: pad(H),
					M: M,
					MM: pad(M),
					s: s,
					ss: pad(s),
					l: pad(L, 3),
					L: pad(L > 99 ? Math.round(L / 10) : L),
					t: H < 12 ? "a" : "p",
					tt: H < 12 ? "am" : "pm",
					T: H < 12 ? "A" : "P",
					TT: H < 12 ? "AM" : "PM",
					Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
					o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
					S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
				};

			return mask.replace(token, function ($0) {
				return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
			});
		};
	}();

	var defaultConfig = {

		// INHERIT
		// showScale: true,							// Boolean - If we should show the scale at all
		// scaleLineColor: "rgba(0,0,0,.1)",		// String - Colour of the scale line
		// scaleLineWidth: 1,						// Number - Pixel width of the scale line
		// scaleShowLabels: true,					// Boolean - Whether to show labels on the scale
		// scaleLabel: "<%=value%>",				// Interpolated JS string - can access value
		scaleArgLabel: "<%=value%>",				// Interpolated JS string - can access value
		scaleSizeLabel: "<%=value%>",				// Interpolated JS string - can access value

		emptyDataMessage: "chart has no data",		// String - Message for empty data

		// SCALE
		scaleShowGridLines: true,				//Boolean - Whether grid lines are shown across the chart
		scaleGridLineWidth: 1,					//Number - Width of the grid lines
		scaleGridLineColor: "rgba(0,0,0,.05)",	//String - Colour of the grid lines
		scaleShowHorizontalLines: true,			//Boolean - Whether to show horizontal lines (except X axis)
		scaleShowVerticalLines: true,			//Boolean - Whether to show vertical lines (except Y axis)

		// DATE SCALE
		scaleType: "number",
		useUtc: true,
		scaleDateFormat: "mmm d",
		scaleTimeFormat: "h:MM",
		scaleDateTimeFormat: "mmm d, yyyy, hh:MM",

		// LINES
		datasetStroke: true,				// Boolean - Whether to show a stroke for datasets
		datasetStrokeWidth: 2,				// Number - Pixel width of dataset stroke
		datasetStrokeColor: '#007ACC',		// String - Color of dataset stroke
		datasetPointStrokeColor: 'white',	// String - Color of dataset stroke
		continueToEnd: true,  // Keep lines across to end

		// POINTS
		pointDot: true,					// Boolean - Whether to show a dot for each point
		pointDotStrokeWidth: 1,			// Number - Pixel width of point dot stroke
		pointDotRadius: 4,				// Number - Radius of each point dot in pixels
		pointHitDetectionRadius: 4,		// Number - amount extra to add to the radius to cater for hit detection outside the drawn point

		multiTooltipTemplate: "<%=argLabel%>; <%=valueLabel%>",
		tooltipTemplate: "<%if (datasetLabel){%><%=datasetLabel%>: <%}%><%=argLabel%>; <%=valueLabel%>",
		legendTemplate: "<ul class=\"<%=name.toLowerCase()%>-legend\"><%for(var i=0;i<datasets.length;i++){%><li><span class=\"<%=name.toLowerCase()%>-legend-marker\" style=\"background-color:<%=datasets[i].strokeColor%>\"></span><%=datasets[i].label%></li><%}%></ul>"
	};

	chartjs.StepNumberScale = chartjs.Element.extend({

		initialize: function () {

			this.font = helpers.fontString(this.fontSize, this.fontStyle, this.fontFamily);
			this.padding = this.fontSize / 2;
		},

		setDataRange: function (dataRange) {

			this.dataRange = dataRange;
		},

		api: {

			generateLabels: function (templateString, numberOfSteps, graphMin, stepValue) {

				var labelsArray = new Array(numberOfSteps + 1),
						stepDecimalPlaces = helpers.getDecimalPlaces(stepValue);

				if (templateString) {

					helpers.each(labelsArray, function (val, index) {

						labelsArray[index] = helpers.template(templateString, { value: (graphMin + (stepValue * (index))).toFixed(stepDecimalPlaces) });

					});
				}
				return labelsArray;
			}
		},

		calculateYscaleRange: function () {

			if (this.scaleOverride) {

				this.yScaleRange = {
					steps: this.scaleSteps,
					stepValue: this.scaleStepWidth,
					min: this.scaleStartValue,
					max: this.scaleStartValue + (this.scaleSteps * this.scaleStepWidth)
				};
			} else {

				this.yScaleRange = helpers.calculateScaleRange(
									[this.dataRange.ymin, this.dataRange.ymax],
									this.chart.height,
									this.fontSize,
									this.beginAtZero,	// beginAtZero,
									this.integersOnly); // integersOnly				
			}
		},

		calculateXscaleRange: function () {

			if (this.xScaleOverride) {

				this.xScaleRange = {
					steps: this.xScaleSteps,
					stepValue: this.xScaleStepWidth,
					min: this.xScaleStartValue,
					max: this.xScaleStartValue + (this.xScaleSteps * this.xScaleStepWidth)
				};
			} else {

				this.xScaleRange = helpers.calculateScaleRange(
					[this.dataRange.xmin, this.dataRange.xmax],
					this.chart.width,
					this.fontSize,
					false,	// beginAtZero,
					true); // integersOnly
			}
		},

		generateYLabels: function () {

			this.yLabels = this.api.generateLabels(
				this.labelTemplate,
				this.yScaleRange.steps,
				this.yScaleRange.min,
				this.yScaleRange.stepValue);
		},

		generateXLabels: function () {

			this.xLabels = this.api.generateLabels(
				this.argLabelTemplate,
				this.xScaleRange.steps,
				this.xScaleRange.min,
				this.xScaleRange.stepValue);
		},

		argToString: function (arg) {

			return +arg + "";
		},

		fit: function () {

			// labels & padding
			this.calculateYscaleRange();
			this.calculateXscaleRange();
			this.generateYLabels();
			this.generateXLabels();

			var xLabelMaxWidth = helpers.longestText(this.chart.ctx, this.font, this.xLabels);
			var yLabelMaxWidth = helpers.longestText(this.chart.ctx, this.font, this.yLabels);

			this.xPadding = this.display && this.showLabels
				? yLabelMaxWidth + this.padding * 2
				: this.padding;

			var xStepWidth = Math.floor((this.chart.width - this.xPadding) / this.xScaleRange.steps);
			var xLabelHeight = this.fontSize * 1.5;
			this.xLabelRotation = xLabelMaxWidth > xStepWidth;

			this.xPaddingRight = this.display && this.showLabels && !this.xLabelRotation
				? xLabelMaxWidth / 2
				: this.padding;

			this.yPadding = this.display && this.showLabels
				? (this.xLabelRotation ? xLabelMaxWidth : xLabelHeight) + this.padding * 2
				: this.padding;
		},

		updatePoints: function (dataSetPoints, ease) {

			for (var i = 0; i < dataSetPoints.length; i++) {

				var current = dataSetPoints[i];

				current.x = this.calculateX(current.arg);
				current.y = this.calculateY(current.value, ease);
			}
		},

		calculateX: function (x) {

			return this.xPadding + ((x - this.xScaleRange.min) * (this.chart.width - this.xPadding - this.xPaddingRight) / (this.xScaleRange.max - this.xScaleRange.min));
		},
		calculateY: function (y, ease) {

			return this.chart.height - this.yPadding - ((y - this.yScaleRange.min) * (this.chart.height - this.yPadding - this.padding) / (this.yScaleRange.max - this.yScaleRange.min)) * (ease || 1);
		},

		draw: function () {

			var ctx = this.chart.ctx, value, index;

			if (this.display) {

				var xpos1 = this.calculateX(this.xScaleRange.min);
				var xpos2 = this.chart.width;
				var ypos1 = this.calculateY(this.yScaleRange.min);
				var ypos2 = 0;

				// y axis
				for (index = 0, value = this.yScaleRange.min;
					 index <= this.yScaleRange.steps;
					 index++, value += this.yScaleRange.stepValue) {

					var ypos = this.calculateY(value);

					if (this.showLabels || this.showHorizontalLines) {

						// line color
						ctx.lineWidth = index == 0 ? this.lineWidth : this.gridLineWidth;
						ctx.strokeStyle = index == 0 ? this.lineColor : this.gridLineColor;

						ctx.beginPath();
						ctx.moveTo(xpos1 - this.padding, ypos);
						ctx.lineTo(this.showHorizontalLines || index == 0 ? xpos2 : xpos1, ypos);
						ctx.stroke();
					}

					// labels
					if (this.showLabels) {

						ctx.lineWidth = this.lineWidth;
						ctx.strokeStyle = this.lineColor;

						// text
						ctx.textAlign = "right";
						ctx.textBaseline = "middle";
						ctx.font = this.font;
						ctx.fillStyle = this.textColor;
						ctx.fillText(this.yLabels[index], xpos1 - this.padding * 1.4, ypos);
					}
				}

				// x axis
				for (index = 0, value = this.xScaleRange.min;
					 index <= this.xScaleRange.steps;
					 index++, value += this.xScaleRange.stepValue) {

					var xpos = this.calculateX(value);

					if (this.showLabels || this.showVerticalLines) {

						// line color
						ctx.lineWidth = index == 0 ? this.lineWidth : this.gridLineWidth;
						ctx.strokeStyle = index == 0 ? this.lineColor : this.gridLineColor;

						ctx.beginPath();
						ctx.moveTo(xpos, ypos1 + this.padding);
						ctx.lineTo(xpos, this.showVerticalLines || index == 0 ? ypos2 : ypos1);
						ctx.stroke();
					}

					// labels
					if (this.showLabels) {

						ctx.lineWidth = this.lineWidth;
						ctx.strokeStyle = this.lineColor;

						// text
						ctx.save();
						ctx.translate(xpos, ypos1 + (this.padding * 1.4));
						ctx.rotate(this.xLabelRotation ? -Math.PI / 2 : 0);
						ctx.textAlign = (this.xLabelRotation) ? "right" : "center";
						ctx.textBaseline = (this.xLabelRotation) ? "middle" : "top";
						ctx.font = this.font;
						ctx.fillStyle = this.textColor;
						ctx.fillText(this.xLabels[index], 0, 0);
						ctx.restore();
					}
				}
			}
		}
	});

	chartjs.StepDateScale = chartjs.StepNumberScale.extend({

		_calculateDateScaleRange: function (valueMin, valueMax, drawingSize, fontSize) {

			// todo: move to global object
			var units = [
				{ u: 1, c: 1, t: 1, n: 'ms' },
				{ u: 1, c: 2, t: 2, n: 'ms' },
				{ u: 1, c: 5, t: 5, n: 'ms' },
				{ u: 1, c: 10, t: 10, n: 'ms' },
				{ u: 1, c: 20, t: 20, n: 'ms' },
				{ u: 1, c: 50, t: 50, n: 'ms' },
				{ u: 1, c: 100, t: 100, n: 'ms' },
				{ u: 1, c: 200, t: 200, n: 'ms' },
				{ u: 1, c: 500, t: 500, n: 'ms' },
				{ u: 1000, c: 1, t: 1000, n: 's' },
				{ u: 1000, c: 2, t: 2000, n: 's' },
				{ u: 1000, c: 5, t: 5000, n: 's' },
				{ u: 1000, c: 10, t: 10000, n: 's' },
				{ u: 1000, c: 15, t: 15000, n: 's' },
				{ u: 1000, c: 20, t: 20000, n: 's' },
				{ u: 1000, c: 30, t: 30000, n: 's' },
				{ u: 60000, c: 1, t: 60000, n: 'm' },
				{ u: 60000, c: 2, t: 120000, n: 'm' },
				{ u: 60000, c: 5, t: 300000, n: 'm' },
				{ u: 60000, c: 10, t: 600000, n: 'm' },
				{ u: 60000, c: 15, t: 900000, n: 'm' },
				{ u: 60000, c: 20, t: 1200000, n: 'm' },
				{ u: 60000, c: 30, t: 1800000, n: 'm' },
				{ u: 3600000, c: 1, t: 3600000, n: 'h' },
				{ u: 3600000, c: 2, t: 7200000, n: 'h' },
				{ u: 3600000, c: 3, t: 10800000, n: 'h' },
				{ u: 3600000, c: 4, t: 14400000, n: 'h' },
				{ u: 3600000, c: 6, t: 21600000, n: 'h' },
				{ u: 3600000, c: 8, t: 28800000, n: 'h' },
				{ u: 3600000, c: 12, t: 43200000, n: 'h' },
				{ u: 86400000, c: 1, t: 86400000, n: 'd' },
				{ u: 86400000, c: 2, t: 172800000, n: 'd' },
				{ u: 86400000, c: 4, t: 345600000, n: 'd' },
				{ u: 86400000, c: 5, t: 432000000, n: 'd' },
				{ u: 604800000, c: 1, t: 604800000, n: 'w' }];

			var maxSteps = drawingSize / (fontSize * 3.3);

			var valueRange = +valueMax - valueMin,
				offset = this.useUtc ? 0 : new Date().getTimezoneOffset() * 60000,
				min = +valueMin - offset,
				max = +valueMax - offset;

			var xp = 0, f = [2, 3, 5, 7, 10];

			while (valueRange / units[xp].t > maxSteps) {
				xp++;

				if (xp == units.length) {

					var last = units[units.length - 1];
					for (var fp = 0; fp < f.length; fp++) {
						units.push({
							u: last.u,
							c: last.c * f[fp],
							t: last.c * f[fp] * last.u,
							n: last.n
						});
					}
				}
			}

			var stepValue = units[xp].t,
				start = Math.floor(min / stepValue) * stepValue,
				stepCount = Math.ceil((max - start) / stepValue),
				end = start + stepValue * stepCount;

			return {
				min: start + offset,
				max: end + offset,
				steps: stepCount,
				stepValue: stepValue
			};
		},

		calculateXscaleRange: function () {

			this.xScaleRange = this._calculateDateScaleRange(
				this.dataRange.xmin,
				this.dataRange.xmax,
				this.chart.width,
				this.fontSize
			);
		},

		argToString: function (arg) {

			return dateFormat(+arg, this.dateTimeFormat, this.useUtc);
		},

		generateXLabels: function () {

			var graphMin = this.xScaleRange.min,
				stepValue = this.xScaleRange.stepValue,
				labelsArray = new Array(this.xScaleRange.steps + 1);

			helpers.each(labelsArray, function (val, index) {

				var value = graphMin + stepValue * index;

				labelsArray[index] = hlp.formatDateValue(value, this.timeFormat, this.dateFormat, this.useUtc);
			}, this);

			this.xLabels = labelsArray;
		}
	});

	chartjs.StepDataSet = (function () {

		var datasetCtr = function (datasetOptions, chartOptions, chart, scale) {

			this.chart = chart;
			this.scale = scale;

			this.label = datasetOptions.label || null;
			this.strokeColor = datasetOptions.strokeColor || chartOptions.datasetStrokeColor;
			this.pointColor = datasetOptions.pointColor || datasetOptions.strokeColor || chartOptions.datasetStrokeColor;
			this.pointStrokeColor = datasetOptions.pointStrokeColor || chartOptions.datasetPointStrokeColor;

			this.pointDot = chartOptions.pointDot;
			this.pointDotRadius = chartOptions.pointDotRadius;
			this.pointHitDetectionRadius = chartOptions.pointHitDetectionRadius;
			this.pointDotStrokeWidth = chartOptions.pointDotStrokeWidth;

			this.scaleArgLabel = chartOptions.scaleArgLabel;
			this.scaleLabel = chartOptions.scaleLabel;
			this.scaleSizeLabel = chartOptions.scaleSizeLabel;

			this.points = [];
		};

		datasetCtr.prototype.addPoint = function (x, y, r) {

			// default size
			r = arguments.length < 3 ? 1 : r;

			var point = this._createNewPoint();
			this._setPointData(point, x, y, r);
			this.points.push(point);
		};

		datasetCtr.prototype.setPointData = function (index, x, y, r) {

			// default size
			r = arguments.length < 4 ? 1 : r;

			var point = hlp.getElementOrDefault(this.points, index);

			if (point) {

				this._setPointData(point, x, y, r);
			}
		};

		datasetCtr.prototype.removePoint = function (index) {

			if (index >= 0 && index < this.points.length) {

				this.points.splice(index, 1);
			}
		};

		datasetCtr.prototype._createNewPoint = function () {

			return new hlp.StepPoint({

				ctx: this.chart.ctx,
				datasetLabel: this.label,

				// point
				display: this.pointDot,
				radius: this.pointDotRadius,
				hitDetectionRadius: this.pointHitDetectionRadius,
				strokeWidth: this.pointDotStrokeWidth,

				// colors
				strokeColor: this.pointStrokeColor,
				highlightStroke: this.pointColor,
				fillColor: this.pointColor,
				highlightFill: this.pointStrokeColor
			});
		};

		datasetCtr.prototype._setPointData = function (point, x, y, r) {

			var formattedArg = this.scale.argToString(+x),
				formattedValue = +y + "",
				formattedSize = +r + "";

			point.arg = +x;
			point.value = +y;
			point.size = +r;  // for use in templates

			point.argLabel = helpers.template(this.scaleArgLabel, { value: formattedArg }),
			point.valueLabel = helpers.template(this.scaleLabel, { value: formattedValue });
			point.sizeLabel = helpers.template(this.scaleSizeLabel, { value: formattedSize });
		};

		return datasetCtr;
	})();

	chartjs.Type.extend({
		name: "Step",

		defaults: defaultConfig,

		initialize: function (datasets) {

			this.hasData = false;
			this.datasets = [];
			this.scale = this._initScale();

			// Compatibility layer
			if (datasets.datasets) {
				datasets = datasets.datasets;
			}

			//Iterate through each of the datasets, and build this into a property of the chart
			helpers.each(datasets, function (dataset) {

				var datasetObject = new chartjs.StepDataSet(dataset, this.options, this.chart, this.scale);

				this.datasets.push(datasetObject);

				this.hasData |= !!dataset.data.length;

				helpers.each(dataset.data, function (dataPoint) {

					datasetObject.addPoint(dataPoint.x, dataPoint.y, dataPoint.r || 1);
				});

			}, this);

			//Set up tooltip events on the chart
			if (this.options.showTooltips) {

				helpers.bindEvents(this, this.options.tooltipEvents, function (evt) {

					var activePoints = (evt.type !== 'mouseout') ? this.getPointsAtEvent(evt) : [];

					this._forEachPoint(function (point) {

						point.restore(['fillColor', 'strokeColor']);
					});

					helpers.each(activePoints, function (activePoint) {

						activePoint.fillColor = activePoint.highlightFill;
						activePoint.strokeColor = activePoint.highlightStroke;
					});

					this.showTooltip(activePoints);
				});
			}

			var dataRange = this._calculateRange();
			this.scale.setDataRange(dataRange);

			this.update();
		},

		_initScale: function () {

			var scaleOptions = {
				chart: this.chart,

				textColor: this.options.scaleFontColor,
				fontSize: this.options.scaleFontSize,
				fontStyle: this.options.scaleFontStyle,
				fontFamily: this.options.scaleFontFamily,

				labelTemplate: this.options.scaleLabel,
				argLabelTemplate: this.options.scaleArgLabel,
				showLabels: this.options.scaleShowLabels,
				beginAtZero: this.options.scaleBeginAtZero,
				integersOnly: this.options.scaleIntegersOnly,

				gridLineWidth: (this.options.scaleShowGridLines) ? this.options.scaleGridLineWidth : 0,
				gridLineColor: (this.options.scaleShowGridLines) ? this.options.scaleGridLineColor : "rgba(0,0,0,0)",
				showHorizontalLines: this.options.scaleShowHorizontalLines,
				showVerticalLines: this.options.scaleShowVerticalLines,
				lineWidth: this.options.scaleLineWidth,
				lineColor: this.options.scaleLineColor,
				display: this.options.showScale,

				// y range
				xScaleOverride: this.options.xScaleOverride,
				xScaleSteps: this.options.xScaleSteps,
				xScaleStepWidth: this.options.xScaleStepWidth,
				xScaleStartValue: this.options.xScaleStartValue,

				// y range
				scaleOverride: this.options.scaleOverride,
				scaleSteps: this.options.scaleSteps,
				scaleStepWidth: this.options.scaleStepWidth,
				scaleStartValue: this.options.scaleStartValue,

				// dates
				useUtc: this.options.useUtc,
				dateFormat: this.options.scaleDateFormat,
				timeFormat: this.options.scaleTimeFormat,
				dateTimeFormat: this.options.scaleDateTimeFormat
			};

			return this.options.scaleType === "date"
				? new chartjs.StepDateScale(scaleOptions)
				: new chartjs.StepNumberScale(scaleOptions);
		},

		// helpers
		getPointsAtEvent: function (e) {
			var pointsArray = [],
				eventPosition = helpers.getRelativePosition(e);
			helpers.each(this.datasets, function (dataset) {
				helpers.each(dataset.points, function (point) {
					if (point.inRange(eventPosition.x, eventPosition.y)) pointsArray.push(point);
				});
			}, this);
			return pointsArray;
		},

		showTooltip: function (elements) {

			this.draw();

			if (elements.length > 0) {

				var firstElement = elements[0];
				var tooltipPosition = firstElement.tooltipPosition();

				if (elements.length == 1) {

					new chartjs.Tooltip({
						x: Math.round(tooltipPosition.x),
						y: Math.round(tooltipPosition.y),
						xPadding: this.options.tooltipXPadding,
						yPadding: this.options.tooltipYPadding,
						fillColor: this.options.tooltipFillColor,
						textColor: this.options.tooltipFontColor,
						fontFamily: this.options.tooltipFontFamily,
						fontStyle: this.options.tooltipFontStyle,
						fontSize: this.options.tooltipFontSize,
						caretHeight: this.options.tooltipCaretSize,
						cornerRadius: this.options.tooltipCornerRadius,
						text: helpers.template(this.options.tooltipTemplate, firstElement),
						chart: this.chart,
						custom: this.options.customTooltips
					}).draw();
				} else {

					var tooltipLabels = [],
						tooltipColors = [];

					helpers.each(elements, function (point) {

						tooltipLabels.push(helpers.template(this.options.multiTooltipTemplate, point));

						tooltipColors.push({
							fill: point._saved.fillColor || point.fillColor,
							stroke: point._saved.strokeColor || point.strokeColor
						});

					}, this);

					new chartjs.MultiTooltip({
						x: Math.round(tooltipPosition.x),
						y: Math.round(tooltipPosition.y),
						xPadding: this.options.tooltipXPadding,
						yPadding: this.options.tooltipYPadding,
						xOffset: this.options.tooltipXOffset,
						fillColor: this.options.tooltipFillColor,
						textColor: this.options.tooltipFontColor,
						fontFamily: this.options.tooltipFontFamily,
						fontStyle: this.options.tooltipFontStyle,
						fontSize: this.options.tooltipFontSize,
						titleTextColor: this.options.tooltipTitleFontColor,
						titleFontFamily: this.options.tooltipTitleFontFamily,
						titleFontStyle: this.options.tooltipTitleFontStyle,
						titleFontSize: this.options.tooltipTitleFontSize,
						cornerRadius: this.options.tooltipCornerRadius,
						labels: tooltipLabels,
						legendColors: tooltipColors,
						legendColorBackground: this.options.multiTooltipKeyBackground,
						title: '',
						chart: this.chart,
						ctx: this.chart.ctx,
						custom: this.options.customTooltips
					}).draw();
				}
			}

			return this;
		},

		_forEachPoint: function (callback) {

			helpers.each(this.datasets, function (dataset) {

				helpers.each(dataset.points, callback, this);
			}, this);
		},

		_forEachDataset: function (callback) {

			helpers.each(this.datasets, callback, this);
		},

		_calculateRange: function () {

			var xmin = undefined,
				xmax = undefined,
				ymin = undefined,
				ymax = undefined;

			this._forEachPoint(function (point) {

				// min x
				if (xmin === undefined || point.arg < xmin) {
					xmin = point.arg;
				}

				// max x
				if (xmax === undefined || point.arg > xmax) {
					xmax = point.arg;
				}

				// min y
				if (ymin === undefined || point.value < ymin) {
					ymin = point.value;
				}

				// max y
				if (ymax === undefined || point.value > ymax) {
					ymax = point.value;
				}
			});

			return {
				xmin: xmin,
				xmax: xmax,
				ymin: ymin,
				ymax: ymax
			}
		},

		_drawMessage: function (message) {

			var ctx = this.chart.ctx,
				width = this.chart.width,
				height = this.chart.height,

				fontSize = this.options.scaleFontSize,
				fontStyle = this.options.scaleFontStyle,
				fontFamily = this.options.scaleFontFamily,
				font = helpers.fontString(fontSize, fontStyle, fontFamily);

			// text
			ctx.save();
			ctx.translate(width / 2, height / 2);
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.font = font;
			ctx.fillStyle = this.options.scaleFontColor;
			ctx.fillText(message, 0, 0);
			ctx.restore();
		},

		_drawLine: function (dataset) {

			var ctx = this.chart.ctx,
				prev = undefined;

			ctx.lineJoin = "round";
			ctx.lineWidth = this.options.datasetStrokeWidth;
			ctx.strokeStyle = dataset.strokeColor || this.options.datasetStrokeColor;

			ctx.beginPath();

			helpers.each(dataset.points, function (point, index) {

				if (index === 0) {

					ctx.moveTo(point.x, point.y);
				}
				else {
				  // First move in x, then y
				  ctx.lineTo(point.x, prev.y);
				  ctx.lineTo(point.x, point.y);
				}
				prev = point;

			}, this);

			if (this.options.continueToEnd)
			  ctx.lineTo(this.chart.width, prev.y);

			ctx.stroke();

		},

		update: function () {

			var dataRange = this._calculateRange();
			this.scale.setDataRange(dataRange);

			this.render();
		},

		draw: function (ease) {

			if (this.hasData) {

				// update view params
				this.scale.fit();

				this._forEachDataset(function (dataset) {

					this.scale.updatePoints(dataset.points, ease);

				});

				// draw
				this.clear();
				this.scale.draw();

				// draw lines
				if (this.options.datasetStroke) {

					helpers.each(this.datasets, this._drawLine, this);
				}

				// draw points
				if (this.options.pointDot) {

					this._forEachPoint(function (point) { point.draw(); });
				}
			} else {

				this.clear();
				this._drawMessage(this.options.emptyDataMessage);
			}
		}
	});

}));
/**
 * Copyright 2018 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var challengeCtrls = angular.module('challengeCtrls', [
    'ngResource',
    'ngRoute',
    'challengeServices',
    'globalServices',
    ]);

challengeCtrls.controller('ChallengeGridCtrl', [
    '$rootScope',
    '$scope',
    '$location',
    'challengeService',
    'configService',
    'loadingService',
    'scoreService',
    'tagService',
    function($rootScope, $scope, $location, challengeService, configService,
      loadingService, scoreService, tagService) {
      $scope.currChall = null;
      $scope.shownTags = {};
      $scope.config = configService.get();
      $scope.challenges = [];

      var compareChallenges = function(a, b) {
        return (a.weight - b.weight);
      };

      var refresh = function(cb) {
          console.log('Refresh grid.');
          challengeService.get(function(data) {
              data.challenges.sort(compareChallenges);
              $scope.challenges = data.challenges;
              if (cb !== undefined && cb !== null) {
                  cb();
              }
          });
      };

      tagService.getList(function(tags) {
        $scope.allTags = tags.tags;
        for (var i = 0; i < $scope.allTags.length; i++) {
          $scope.shownTags[$scope.allTags[i].tagslug] = 1;
        }
      })

      $scope.goChallenge = function(chall) {
        $scope.currChall = chall;
        $('#challenge-modal').modal('show');
      };

      $scope.flipSide = function(chall) {
        if (chall.answered)
          return "Solved! (" + scoreService.getCurrentPoints(chall) + " points)";
        else
          return scoreService.getCurrentPoints(chall) + " points";
      };

      $scope.tagsAllowed = function(chall) {
        var containsTag = function(chall, tagslug) {
            for (var i = 0; i < chall.tags.length; i++) {
              if (chall.tags[i].tagslug == tagslug) return true;
            }
            return false;
        }

        //Check for prohibition
        for (var i = 0; i < chall.tags.length; i++) {
          var type = $scope.shownTags[chall.tags[i].tagslug];
          if (type == 0) {
            return false;
          }
        }

        //Check for inclusion
        for (var i in $scope.shownTags) {
          if ($scope.shownTags[i] == 2 && !containsTag(chall, i)) {
            return false;
          }
        }
        return true;
      }

      $scope.toggleTag = function(t, click) {
        var tindex = $scope.shownTags[t];
        //Return next permutation
        if (click == 0) {
          tindex += 1;
        } else {
          tindex += 3-1;
        }
        $scope.shownTags[t] = tindex % 3;
      }

      $scope.getSentiment = function(tag) {
        var sentiments = [
          'sentiment_dissatisfied',
          'sentiment_neutral',
          'sentiment_satisfied'];
        return sentiments[$scope.shownTags[tag.tagslug]];
      }

      refresh(loadingService.stop);

      $rootScope.$on('correctAnswer', (e) => refresh());
  }]);
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var scoreboardCtrls = angular.module('scoreboardCtrls', [
    'ngResource',
    'globalServices'
    ]);

scoreboardCtrls.controller('ScoreboardCtrl', [
    '$scope',
    '$resource',
    '$interval',
    'configService',
    'errorService',
    'loadingService',
    function($scope, $resource, $interval, configService, errorService,
        loadingService) {
      $scope.config = configService.get();

      var topTeams = function(scoreboard, numTeams) {
        // Scoreboard data is sorted by backend
        var numTeams = numTeams || 10;
        return scoreboard.slice(0, numTeams);
      };

      var getHistory = function(scoreboard) {
        var histories = {};
        angular.forEach(topTeams(scoreboard), function(entry) {
          histories[entry.name] = entry.history;
        });
        return histories;
      };
      
      var refresh = function() {
        errorService.clearErrors();
        $resource('/api/scoreboard').get(
            function(data) {
              $scope.scoreboard = data.scoreboard;
              $scope.scoreHistory = getHistory(data.scoreboard);
              loadingService.stop();
            },
            function(data) {
              errorService.error(data);
              loadingService.stop();
            });
      };

      refresh();
      var iprom = $interval(refresh, 60000);

      $scope.$on('$destroy', function() {
          $interval.cancel(iprom);
      });
    }]);
/**
 * Copyright 2018 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var teamCtrls = angular.module('teamCtrls', [
    'teamServices',
    'globalServices',
    ]);

teamCtrls.controller('TeamPageCtrl', [
    '$scope',
    '$routeParams',
    'teamService',
    'errorService',
    'loadingService',
    function($scope, $routeParams, teamService, errorService, loadingService) {
      var tid = $routeParams.tid;
      teamService.get({tid: tid},
          function(team) {
            $scope.team = team;
            var tagData = {};
            angular.forEach(team.solved_challenges, function(chall) {
              angular.forEach(chall.tags, function(tag) {
                if (!(tag.tagslug in tagData))
                  tagData[tag.tagslug] = chall.points;
                else
                  tagData[tag.tagslug] += chall.points;
              });
            });
            $scope.tagData = tagData;
            $scope.scoreHistory = {};
            $scope.scoreHistory[team.name] = team.score_history;
            $scope.scoreHistory[team.name].sort(function(a, b) {
                return (Date.parse(a.solved) - Date.parse(b.solved));
            });
            loadingService.stop();
          },
          function(err) {
            errorService.error('Unable to load team info.');
            loadingService.stop();
          });
    }]);
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var globalCtrls = angular.module('globalCtrls', [
    'globalServices',
    'sessionServices',
    ]);

globalCtrls.controller('GlobalCtrl', [
    '$scope',
    'configService',
    function($scope, configService) {
        $scope.config = configService.get();
    }]);

globalCtrls.controller('LoggedInCtrl', [
    '$scope',
    'sessionService',
    function($scope, sessionService) {
      $scope.session = sessionService.session;
      $scope.loggedIn = function(){
        return !!sessionService.session.user;
      };
      $scope.isAdmin = function(){
        return (!!sessionService.session.user &&
          sessionService.session.user.admin);
      };
    }]);

globalCtrls.controller('ErrorCtrl', [
    '$scope',
    'errorService',
    function($scope, errorService) {
      $scope.errors = errorService.errors;

      $scope.$on('$locationChangeStart', function(ev) {
        errorService.clearErrors();
      });
    }]);

globalCtrls.controller('NewsCtrl', [
    '$scope',
    'newsService',
    function($scope, newsService) {
        $scope.latest = 0;
        var updateNews = function(newsItems) {
            var latest = 0;
            angular.forEach(newsItems, function(item) {
                var d = Date.parse(item.timestamp);
                if (d > latest)
                  latest = d;
            });
            if (latest > $scope.latest) {
                // TODO: call attention to new news
                $scope.latest = latest;
                $scope.newsItems = newsItems;
            }
        };

        newsService.registerClient(updateNews);
        newsService.start();
    }]);
/**
 * Copyright 2018 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var adminChallengeCtrls = angular.module('adminChallengeCtrls', [
    'ngResource',
    'ngRoute',
    'challengeServices',
    'globalServices',
    'sessionServices',
    'uploadServices',
    ]);

adminChallengeCtrls.controller('AdminTagCtrl', [
    '$scope',
    'tagService',
    'errorService',
    'sessionService',
    'loadingService',
    function($scope, tagService, errorService, sessionService, loadingService) {
      if (!sessionService.requireAdmin()) return;

      $scope.tags = [];

      $scope.updateTag = function(tag) {
        errorService.clearErrors();
        tagService.save({tagslug: tag.tagslug}, tag,
          function(data) {
            errorService.error(tag.name + ' updated.', 'success');
          },
          function(data) {
            errorService.error(data);
          });
      };

      $scope.deleteTag = function(tag) {
        errorService.clearErrors();
        var name = tag.name;
        tagService.delete({tagslug: tag.tagslug},
          function(data) {
            var idx = $scope.tags.indexOf(tag);
            $scope.tags.splice(idx, 1);
            errorService.error(name + ' deleted.', 'success');
          },
          function(data) {
            errorService.error(data);
          });
      };

      $scope.addTag = function() {
        errorService.clearErrors();
        tagService.create({}, $scope.newTag,
          function(data) {
            $scope.tags.push(data);
            $scope.newTag = {};
          },
          function(data) {
            errorService.error(data);
          });
      };

      $scope.newTag = {};

      $scope.invalidForm = function(idx) {
          var form = $(document.getElementsByName('adminTagForm[' + idx + ']'));
          return form.hasClass('ng-invalid');
      };

      sessionService.requireLogin(function() {
        errorService.clearErrors();
        tagService.get(
          function(data) {
            $scope.tags = data.tags;
            loadingService.stop();
          },
          function(data) {
            errorService.error(data);
            loadingService.stop();
          });
      });
    }]);

adminChallengeCtrls.controller('AdminPagesCtrl', [
    '$scope',
    'pageService',
    'errorService',
    'sessionService',
    'loadingService',
    function($scope, pageService, errorService, sessionService, loadingService) {
        if (!sessionService.requireAdmin()) return;

        $scope.active = {};
        $scope.activate = function(p) {
            if (p.new == p.path) {
                $scope.active = p;
                $("#delete-confirm").modal("show");
            } else {
                var oldPath = p.path;
                p.path = p.new;
                pageService.save({path: oldPath}, p)
            }
        }

        $scope.deleteActive = function() {
            pageService.delete({path: $scope.active.path})
            $scope.pages.splice($scope.pages.indexOf($scope.active), 1)
            $scope.active = {}
        }

        sessionService.requireLogin(function() {
            errorService.clearErrors();
            pageService.get(
                function(data) {
                    $scope.pages = data.pages;
                    for (var i = 0; i < $scope.pages.length; i++) {
                        $scope.pages[i].new = $scope.pages[i].path;
                    }
                    loadingService.stop();
                },
                function(data) {
                    errorService.error(data);
                    loadingService.stop();
                });
        });
    }])

adminChallengeCtrls.controller('AdminAttachmentCtrl', [
    '$scope',
    'attachService',
    'errorService',
    'sessionService',
    'loadingService',
    'uploadService',
    function($scope, attachService, errorService, sessionService, loadingService,
        uploadService) {
      if (!sessionService.requireAdmin()) return;

      $scope.attachments = [];

      $scope.updateAttachment = function(attachment, cb) {
        errorService.clearErrors();
        attachService.save({aid: attachment.aid}, attachment,
          function(data) {
            errorService.error(attachment.filename + ' updated.', 'success');
            if (cb) cb(data);
          },
          function(data) {
            errorService.error(data);
          });
      };

      $scope.deleteAttachment = function(attachment) {
        errorService.clearErrors();
        var filename = attachment.filename;
        attachService.delete({aid: attachment.aid},
          function(data) {
            var idx = $scope.attachments.indexOf(attachment);
            $scope.attachments.splice(idx, 1);
            errorService.error(name + ' deleted.', 'success');
          },
          function(data) {
            errorService.error(data);
          });
      };


      $scope.addAttachment = function() {
          $scope.newAttachment.challenges = $scope.newAttachment.challenges || [];
          $scope.updateAttachment($scope.newAttachment, function(data) {
              $scope.newAttachment = {};
              for (var i = 0; i < $scope.attachments.length; i++) {
                  if ($scope.attachments[i].aid == data.aid) return;
              }
              $scope.attachments.push(data);
          });
      }

      $scope.newAttachment = {};

      $scope.invalidForm = function(idx) {
          var form = $(document.getElementsByName('adminAttachmentForm[' + idx + ']'));
          return form.hasClass('ng-invalid');
      };

      $scope.replace = function(a) {
        uploadService.request().then(uploadService.upload).then(function(newfile) {
          if (a.aid == newfile.aid) return;
          attachService.delete({aid: a.aid});
          a.aid = newfile.aid;
          attachService.save({aid: a.aid}, a, function(d) {}, function(e) {
            console.error(e);
          })
        });
      }

      $scope.addfile = function() {
        uploadService.request().then(uploadService.upload).then(function(newfile) {
          $scope.newAttachment.aid = newfile.aid;
        })
      }

      sessionService.requireLogin(function() {
        errorService.clearErrors();
        attachService.get(
          function(data) {
            $scope.attachments = data.attachments;
            loadingService.stop();
          },
          function(data) {
            errorService.error(data);
            loadingService.stop();
          });
      });
    }]);


adminChallengeCtrls.controller('AdminChallengesCtrl', [
    '$scope',
    '$filter',
    '$location',
    '$routeParams',
    'challengeService',
    'errorService',
    'sessionService',
    'loadingService',
    function($scope, $filter, $location, $routeParams, challengeService,
        errorService, sessionService, loadingService) {
      if (!sessionService.requireAdmin()) return;

      var updateChallenges = function(challenges) {
        $scope.challenges = $filter('orderBy')(challenges,
            function(item) {
              return item.weight;
            });
      };

      $scope.lockChallenge = function(challenge, locked) {
        var copy = {};
        angular.forEach(challenge, function(v, k) {
          copy[k] = v;
        });
        copy.unlocked = !locked;
        challengeService.save({cid: challenge.cid},
          copy,
          function(data) {
            challenge.unlocked = data.unlocked;
          },
          function(data) {
            errorService.error(data);
          });
      };

      $scope.deleteChallenge = function(challenge) {
          var name = challenge.name;
          challengeService.delete({cid: challenge.cid},
            function(){
                var idx = $scope.challenges.indexOf(challenge);
                $scope.challenges.splice(idx, 1);
                errorService.error(name + ' deleted.', 'success');
            },
            function(data) {
                errorService.error(data);
            });
      };

      $scope.newChallenge = function() {
        $location.path('/admin/challenge');
      };

      // Ordering things
      var swapChallenges = function(idx, offset) {
        var temp = $scope.challenges[idx];
        $scope.challenges[idx] = $scope.challenges[idx + offset];
        $scope.challenges[idx + offset] = temp;
        $scope.weightsChanged = true;
      };
      $scope.moveUp = function(challenge) {
        var idx = $scope.challenges.indexOf(challenge);
        if (idx < 1) {
          console.log('Attempt to moveUp non-existent or first item.');
          return;
        }
        swapChallenges(idx, -1);
      };
      $scope.moveDown = function(challenge) {
        var idx = $scope.challenges.indexOf(challenge);
        if (idx > ($scope.challenges.length - 1) || idx == -1) {
          console.log('Attempt to moveDown non-existent or last item.');
          return;
        }
        swapChallenges(idx, 1);
      };
      $scope.weightsChanged = false;
      $scope.saveBulk = function() {
        loadingService.start();
        var failed = false;
        // Set new weights
        var weight = 0;
        // Make a copy to avoid overwriting other challenge updates
        challengeService.get(function(data) {
          angular.forEach($scope.challenges, function(mod_chall) {
            weight += 1;
            angular.forEach(data.challenges, function(chall) {
              if (mod_chall.cid == chall.cid) {
                if (weight == chall.weight)
                  return;
                chall.weight = weight;
                challengeService.save({cid: chall.cid},
                    chall,
                    function() {},
                    function(data) {
                      failed = true;
                      errorService.error(data);
                    });
              }
            });
          });
          updateChallenges(data.challenges);
          loadingService.stop();
        },
        function (data) {
          errorService.error(data);
          loadingService.stop();
        });
      };

      sessionService.requireLogin(function() {
        challengeService.get(function(data) {
          updateChallenges(data.challenges);
          loadingService.stop();
        },
        function(data) {
          errorService.error(data);
          loadingService.stop();
        });
      });
    }]);

adminChallengeCtrls.controller('AdminChallengeCtrl', [
    '$scope',
    '$location',
    '$routeParams',
    'challengeService',
    'errorService',
    'sessionService',
    'uploadService',
    'loadingService',
    'tagService',
    'attachService',
    'configService',
    function($scope, $location, $routeParams, challengeService, errorService,
      sessionService, uploadService, loadingService, tagService, attachService,
      configService) {
      if (!sessionService.requireAdmin()) return;

      $scope.cid = $routeParams.cid;
      $scope.newAttachment = {};
      $scope.addNewAttachment = false;
      $scope.action = 'New';
      $scope.editing = false;  // New or editing?
      $scope.config = configService.get();

      var goEdit = function() {
        $scope.action = 'Edit';
        $scope.answerPlaceholder = 'Enter answer; leave blank to ' +
          'leave unchanged.';
        $scope.editing = true;
        if (!$routeParams.cid) {
          $location.path($location.path() + '/' + $scope.challenge.cid);
          $scope.cid = $scope.challenge.cid;
        }
      };

      $scope.saveChallenge = function() {
        errorService.clearErrors();
        // TODO: Check attachments

        if ($scope.challenge.prerequisite && (
          $scope.challenge.prerequisite.type == 'None')) {
          $scope.challenge.prerequisite = null;
        };

        var save_func;
        if ($scope.challenge.cid) {
            save_func = challengeService.save;
        } else {
            save_func = challengeService.create;
        }
        save_func({cid: $scope.challenge.cid},
          $scope.challenge,
          function(data) {
            $scope.challenge = data;
            goEdit();
            errorService.error('Saved.', 'success');
          },
          function(data) {
            errorService.error(data);
          });
      };

      $scope.attachmentType = 'new';

      attachService.get(function(data) {
        $scope.allAttachments = data.attachments;
        $scope.updateAttachments();
      }, function(e) {
        errorService.error(e);
      })

      var setSubtract = function(a, b, key) {
        if (!a) return b;
        if (!b) return [];
        var isIn = function(val) {
          for (var i = 0; i < a.length; i++) {
            if (a[i][key] == val) return true;
          }
          return false;
        }
        var out = []
        for (var i = 0; i < b.length; i++) {
          if (!isIn(b[i][key])) {
            out.push(b[i]);
          }
        }
        return out;
      };

      $scope.updateAttachments = function () {
        if (!$scope.challenge) return;
        $scope.attachments = setSubtract(
          $scope.challenge.attachments, $scope.allAttachments, 'aid');
        $scope.attachmentType = 'new';
      };

      $scope.$watch('challenge.attachments', $scope.updateAttachments, true);

      var addAttachment = function(aid) {
        for (var i = 0; i < $scope.attachments.length; i++) {
          if ($scope.attachments[i].aid == aid) {
            $scope.challenge.attachments.push($scope.attachments[i]);
            return;
          }
        }
        errorService.error('Could not add attachment: '+aid);
      };

      $scope.addAttachment = function() {
        if ($scope.attachmentType == 'new') {
          uploadService.request().then(uploadService.upload).then(function (data) {
            $scope.challenge.attachments.push(data);
          })
        } else {
          addAttachment($scope.attachmentType);
        }
      };

      $scope.verifyFile = function() {
          // Verify existance by hash
          // TODO
      };

      $scope.deleteAttachment = function(attachment) {
        var idx = $scope.challenge.attachments.indexOf(attachment);
        $scope.challenge.attachments.splice(idx, 1);
      };

      // Prerequisite handlers
      $scope.updatePrerequisite = function() {
        var type = $scope.challenge.prerequisite.type || 'None';
        if (type == 'None')
          return;
        if (type == 'solved') {
          // Load the challenge list
          loadingService.start();
          challengeService.get(function(data) {
            $scope.challengeList = [];
            angular.forEach(data.challenges, function(c) {
              $scope.challengeList.push({'cid': c.cid, 'name': c.name});
            })
            loadingService.stop();
          }, function(data) {
            errorService.error(data);
            loadingService.stop();
          });
        }
      };

      $scope.hasTag = function(tag) {
        if (!$scope.challenge) {
          return false;
        }
        for (var i = 0; i < $scope.challenge.tags.length; i++) {
          if (tag == $scope.challenge.tags[i].tagslug) {
            return true;
          }
        }
        return false;
      }

      $scope.toggleTag = function(tagslug) {
        for (var i = 0; i < $scope.challenge.tags.length; i++) {
          if ($scope.challenge.tags[i].tagslug == tagslug) {
            $scope.challenge.tags.splice(i,1);
            return;
          }
        }
        for (var i = 0; i < $scope.tags.length; i++) {
          if ($scope.tags[i].tagslug == tagslug) {
            $scope.challenge.tags.push($scope.tags[i]);
            return;
          }
        }
      }

      /* Setup on load */
      sessionService.requireLogin(function() {
        if ($routeParams.cid) {
          // Editing
          challengeService.get({cid: $routeParams.cid},
            function(data) {
                $scope.challenge = data;
                goEdit();
                $scope.updatePrerequisite();
                loadingService.stop();
            },
            function(data) {
                errorService.error(data);
                loadingService.stop();
            });
        } else {
            // New
            $scope.challenge = {
                'tags': [],
                'attachments': [],
                'prerequisite': {
                  'type': 'None'
                },
                'validator': 'static_pbkdf2'
            };
        }
        tagService.getList(function(data) {
          $scope.tags = data.tags;
        });
        loadingService.stop();
      });

    }]);

adminChallengeCtrls.controller('AdminRestoreCtrl', [
    '$scope',
    '$resource',
    'errorService',
    'sessionService',
    'loadingService',
    function($scope, $resource, errorService, sessionService, loadingService) {
      if (!sessionService.requireAdmin()) return;

      $scope.replace = false;
      $scope.ready = false;
      $scope.fileData = null;
      $scope.fileName = 'No file chosen.';

      $scope.chooseRestoreFile = function() {
        $scope.ready = false;
        $('#restore-file-chooser').click();
      };

      var fileChooserChange = function(evt) {
        $scope.$apply(function() {
          var file = evt.target.files[0];
          if (!file) {
            $scope.fileName = 'No file chosen.';
            return;
          }
          $scope.fileName = file.name;
          var reader = new FileReader();
          reader.onload = function(e) {
            $scope.$apply(function() {
              var contents = e.target.result;
              if (contents.substr(0,6) == ")]}',\n")
                contents = contents.substr(6);
              $scope.fileData = angular.fromJson(contents);
              $scope.ready = true;
            });
          };
          reader.onerror = function(e) {
            $scope.$apply(function() {
              errorService.error('Failed to load file!');
            });
          };
          reader.readAsText(file);
        });
      };

      $('#restore-file-chooser').change(fileChooserChange);
      $scope.$on('$destroy', function() {
        $('#restore-file-chooser').unbind('change', fileChooserChange);
      });

      $scope.submitRestore = function() {
        if (!$scope.ready) {
          // Shouldn't even be here!
          errorService.error('Not ready to submit!');
          return;
        }
        $resource('/api/backup').save({}, {
          challenges: $scope.fileData.challenges,
          replace: $scope.replace
        },
        function(data) {
          errorService.error(data.message, 'success');
          var chooser = $('#restore-file-chooser');
          chooser.replaceWith(chooser.clone(true));
        },
        function(data) {
          errorService.error(data);
        });
      };
      loadingService.stop();
    }]);

/**
 * Copyright 2018 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var adminTeamCtrls = angular.module('adminTeamCtrls', [
    'ngResource',
    'ngRoute',
    'challengeServices',
    'globalServices',
    'sessionServices',
    'teamServices',
    'userServices'
    ]);

adminTeamCtrls.controller('AdminTeamsCtrl', [
    '$scope',
    '$routeParams',
    'answerService',
    'challengeService',
    'errorService',
    'sessionService',
    'teamService',
    'loadingService',
    function($scope, $routeParams, answerService, challengeService, errorService,
        sessionService, teamService, loadingService) {
      if (!sessionService.requireAdmin()) return;

      $scope.teams = [];
      $scope.team = null;
      $scope.unsolved = [];
      $scope.grantee = null;

      $scope.updateTeamModal = function() {
        $("#team-rename").modal("show");
      };

      $scope.updateTeam = function() {
        errorService.clearErrors();
        $scope.team.$save({tid: $scope.team.tid},
          function(data) {
            $scope.team = data;
            errorService.error('Saved.', 'success');
          },
          function(data) {
            errorService.error(data);
          });
      };

      $scope.grantFlag = function(chall) {
        $scope.grantee = chall;
        $("#team-grant").modal("show");
      };

      $scope.grantFlagConfirm = function() {
        answerService.create(
          { cid: $scope.grantee.cid,
            tid: $scope.team.tid },
          function() {
            errorService.error('Flag granted.', 'success');
            refreshTeam($scope.team.tid);
          },
          errorService.error);
      };

      var refreshTeam = function(tid) {
        $scope.team = teamService.get({tid: tid},
          teamLoaded,
          function(data) {
            errorService.error(data);
            loadingService.stop();
          });
      };

      var teamLoaded = function() {
        var tagData = {};
        var solved = [];
        angular.forEach($scope.team.solved_challenges, function(chall) {
          solved.push(chall.cid);
          angular.forEach(chall.tags, function(tag) {
            if (!(tag.tagslug in tagData))
              tagData[tag.tagslug] = chall.points;
            else
              tagData[tag.tagslug] += chall.points;
          });
        });
        $scope.tagData = tagData;
        $scope.scoreHistory = {};
        $scope.scoreHistory[$scope.team.name] = $scope.team.score_history;
        $scope.unsolved = [];

        challengeService.get(function(challs) {
          angular.forEach(challs.challenges, function(ch) {
            if (solved.indexOf(ch.cid) < 0) {
              $scope.unsolved.push(ch);
            }
          });
          loadingService.stop();
        });
      };

      sessionService.requireLogin(function() {
        var tid = $routeParams.tid;
        if (tid) {
          refreshTeam(tid);
        } else {
          teamService.get(function(data) {
            $scope.teams = data.teams;
            loadingService.stop();
          });
        }
      });
    }]);

adminTeamCtrls.controller('AdminUsersCtrl', [
    '$scope',
    '$routeParams',
    'configService',
    'errorService',
    'sessionService',
    'teamService',
    'userService',
    'loadingService',
    function($scope, $routeParams, configService, errorService, sessionService,
      teamService, userService, loadingService) {
      if (!sessionService.requireAdmin()) return;

      $scope.users = [];
      $scope.teams = [];
      $scope.user = null;
      $scope.config = configService.get();

      $scope.updateUser = function() {
        errorService.clearErrors();
        $scope.user.$save({uid: $scope.user.uid},
          function(data) {
            $scope.user = data;
            errorService.error('Saved.', 'success');
          },
          function(data) {
            errorService.error(data);
          });
      };

      var getTeam = function(tid) {
        var team = null;
        angular.forEach($scope.teams, function(t) {
          if (t.tid == tid) {
            team = t;
          }
        });
        return team;
      };

      sessionService.requireLogin(function() {
        teamService.get(function(data) {
          $scope.teams = data.teams;
          var uid = $routeParams.uid;
          if (uid) {
            $scope.user = userService.get({uid: uid},
              function() {
                loadingService.stop();
                $scope.user.team = getTeam($scope.user.team_tid);
              });
          } else {
            userService.get(function(data) {
              $scope.users = data.users;
              angular.forEach($scope.users, function(u) {
                u.team = getTeam(u.team_tid);
              });
              loadingService.stop();
            });
          }
        });
      });  // end requireLogin block
    }]);
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var adminPageCtrls = angular.module('adminPageCtrls', [
    'globalServices',
    'sessionServices',
    'pageServices',
    'ngRoute',
    ]);

adminPageCtrls.controller('AdminPageCtrl', [
    '$scope',
    '$routeParams',
    'errorService',
    'pageService',
    'sessionService',
    'loadingService',
    function($scope, $routeParams, errorService, pageService, sessionService,
        loadingService) {
        if (!sessionService.requireAdmin()) return;

        var path = $routeParams.path;

        $scope.action = 'New Page: ' + path;
        
        var goEdit = function() {
            $scope.action = 'Edit Page: ' + path;
        };

        $scope.save = function() {
            errorService.clearErrors();
            pageService.save({path: path}, $scope.page,
                function(data) {
                    $scope.page = data;
                    errorService.success('Saved.');
                    goEdit();
                },
                function(data) {
                    errorService.error(data);
                });
        };

        $scope.page = {path: path};

        pageService.get({path: path},
            function(data) {
                goEdit();
                $scope.page = data;
                loadingService.stop();
            },
            function(data) {
                loadingService.stop();
                if (data.status == 404)
                    // Don't care, creating a new page?
                    return;
                errorService.error(data);
            });
    }]);
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var adminNewsCtrls = angular.module('adminNewsCtrls', [
    'globalServices',
    'sessionServices',
    'teamServices',
    ]);

adminNewsCtrls.controller('AdminNewsCtrl', [
    '$scope',
    'errorService',
    'newsService',
    'sessionService',
    'teamService',
    'loadingService',
    function($scope, errorService, newsService, sessionService, teamService,
        loadingService) {
        if (!sessionService.requireAdmin()) return;

        var makeNewsItem = function() {
            return {
                'news_type': 'Broadcast'
            }
        };
        $scope.newsItem = makeNewsItem();
        $scope.teams = teamService.get();
        $scope.submitNews = function() {
            errorService.clearErrors();
            newsService.save($scope.newsItem,
                function() {
                    $scope.newsItem = makeNewsItem();
                    newsService.poll();
                    errorService.success('News item saved.');
                },
                function(msg) {
                    errorService.error(msg);
                });
        };
        loadingService.stop();
    }]);
/**
 * Copyright 2018 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var adminToolCtrls = angular.module('adminToolCtrls', [
    'adminServices',
    'sessionServices',
    'userServices',
    ]);

adminToolCtrls.controller('AdminToolCtrl', [
    '$scope',
    'adminToolsService',
    'errorService',
    'sessionService',
    'loadingService',
    'apiKeyService',
    function($scope, adminToolsService, errorService, sessionService, loadingService, apiKeyService) {
        if (!sessionService.requireAdmin()) return;

        $scope.recalculateScores = adminToolsService.recalculateScores;
        $scope.resetScores = function() {
          adminToolsService.resetScores(
            errorService.success, errorService.error);
        };
        $scope.resetPlayers = function() {
          adminToolsService.resetPlayers(
            errorService.success, errorService.error);
        };
        $scope.clearApiKeys = function() {
            apiKeyService.deleteAll(function() {
                errorService.success("Cleared");
            }, function() {
                errorService.error("Failed clearing API keys.");
            });
        };

        loadingService.stop();
    }]);
/**
 * Copyright 2016 Google LLC. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var pageCtrls = angular.module('pageCtrls', [
    'globalServices',
    'pageServices',
    ]);

pageCtrls.controller('StaticPageCtrl', [
    '$scope',
    'pageService',
    'errorService',
    'loadingService',
    function($scope, pageService, errorService, loadingService) {
        $scope.path = pageService.pagePath();
        if ($scope.path == "") {
            $scope.path = "home";
        }
        pageService.get({path: $scope.path},
            function(data) {
                $scope.page = data;
                loadingService.stop();
            },
            function(data) {
                // TODO: better handling here
                errorService.error(data);
                loadingService.stop();
            });
    }]);
/**
 * Copyright 2018 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var regCtrls = angular.module('regCtrls', [
    'globalServices',
    'sessionServices',
    'teamServices',
    'userServices'
    ]);

regCtrls.controller('LoginCtrl', [
    '$scope',
    '$location',
    '$window',
    'configService',
    'errorService',
    'sessionService',
    'passwordResetService',
    'loadingService',
    function($scope, $location, $window, configService, errorService, sessionService,
        passwordResetService, loadingService) {
      if ($location.path().indexOf('/logout') == 0) {
        sessionService.logout(function() {
          $window.location.href = '/';
        });
        return;
      }

      // Check if we should redirect
      configService.get(function(c) {
        if (c.login_method == "local")
          return;
        $window.location.href = c.login_url;
      });

      $scope.email = '';
      $scope.password = '';

      $scope.login = function() {
        errorService.clearErrors();
        sessionService.login($scope.email, $scope.password,
          function() {
            $location.path('/challenges');
          },
          function(errData) {
            errorService.error(errData);
            $scope.password = '';
          });
      };

      $scope.pwreset = function() {
        errorService.clearErrors();
        passwordResetService.get({email: $scope.email},
            function(data) {
                errorService.success(data);
            },
            function(data) {
                errorService.error(data);
            });
      };

      loadingService.stop();
    }]);

regCtrls.controller('RegistrationCtrl', [
    '$scope',
    '$location',
    'configService',
    'errorService',
    'sessionService',
    'teamService',
    'userService',
    'loadingService',
    function($scope, $location, configService, errorService, sessionService,
        teamService, userService, loadingService) {
      $scope.config = configService.get();
      $scope.teams = [];
      teamService.get(function(resp) {
        $scope.teams = resp.teams;
      });
      var search = $location.search();
      if (search['team'] && search['code']) {
        $scope.team_code = search['code'];
        $scope.team = search['team'];
      }

      $scope.register = function() {
        errorService.clearErrors();
        userService.create({
          email: $scope.email,
          nick: $scope.nick,
          password: $scope.password,
          team_id: $scope.team,
          team_name: $scope.team_name,
          team_code: $scope.team_code,
          invite_key: $scope.invite_key
        }, function(data) {
          sessionService.refresh();
          $location.url('/challenges');
        }, function(errData) {
          // TODO: more verbose
          errorService.error(errData);
        });
      };
      loadingService.stop();
    }]);

regCtrls.controller('ProfileCtrl', [
    '$scope',
    '$location',
    'configService',
    'errorService',
    'sessionService',
    'userService',
    'loadingService',
    'gameTimeService',
    'teamService',
    'apiKeyService',
    function($scope, $location, configService, errorService, sessionService,
        userService, loadingService, gameTimeService, teamService,
        apiKeyService) {
      $scope.user = null;

      $scope.started = gameTimeService.started;
      $scope.changing = false;

      $scope.startJoin = function() {
        $scope.changing = true;
        $scope.team.code = "";
        $("#team").focus();
      }

      $scope.cancel = function() {
        $scope.changing = false;
        $scope.team.name = $scope.team.originalname;
        $scope.team.code = $scope.team.originalcode;
      }

      $scope.$watch('team.name', function() {
        if (!($scope.teams && $scope.team && $scope.team.name)) return;
        for (var i = 0; i < $scope.teams.length; i++) {
          if ($scope.teams[i].name == $scope.team.name) {
            return $scope.team.tid = $scope.teams[i].tid;
          }
        }
        $scope.team.tid = -1;
      })

      $scope.switchTeams = function() {
        teamService.change({
          'uid': $scope.user.uid,
          'team_tid': $scope.team.tid,
          'code': $scope.team.code,
        }, function() {
          $scope.team.originalname = $scope.team.name;
          $scope.team.originalcode = $scope.team.code;
          $scope.cancel();
        }, function(data) {
          errorService.error(data);
        })
      }

      var build_team_link = function(team) {
        var link = $location.absUrl().replace($location.url(), '');
        return link + '/register?' + $.param(
          {team: team.tid, code: team.code});
      };

      sessionService.requireLogin(function() {
        $scope.user = sessionService.session.user;
        configService.get(function(c) {
            if (c.teams) {
                $scope.team = sessionService.session.team;
                $scope.team.originalname = $scope.team.name;
                $scope.team.originalcode = $scope.team.code;
                $scope.team_link = build_team_link($scope.team);
            }
            loadingService.stop();
        });
        teamService.get(function(c) {
          $scope.teams = c.teams;
        })
        apiKeyService.get(function(r) {
            $scope.apiKey = r;
        });
        $scope.apiKeyNew = function() {
            apiKeyService.create(function(r) {
                $scope.apiKey = r;
                errorService.success('Created new key.');
            }, errorService.error);
        };
      });

      $scope.updateProfile = function() {
        userService.save({uid: $scope.user.uid}, $scope.user,
          function(data) {
            $scope.user = data;
            sessionService.refresh();
          },
          function(data) {
            errorService.error(data);
          });
      };
    }]);

regCtrls.controller('PasswordResetCtrl', [
    '$scope',
    '$routeParams',
    '$location',
    'passwordResetService',
    'errorService',
    'sessionService',
    'loadingService',
    function($scope, $routeParams, $location, passwordResetService,
        errorService, sessionService, loadingService) {
        $scope.email = $routeParams.email;
        $scope.pwreset = function() {
            errorService.clearErrors();
            passwordResetService.save({email: $routeParams.email},
                {
                    'token': $routeParams.token,
                    'password': $scope.password,
                    'password2': $scope.password2
                },
                function(data) {
                    errorService.clearAndInhibit();
                    errorService.success(data);
                    sessionService.refresh();
                    $location.path('/');
                },
                function(data) {
                    errorService.error(data);
                    $scope.password = '';
                    $scope.password2 = '';
                });
        };
        loadingService.stop();
    }]);
